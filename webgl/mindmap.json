{
    "name": "Sistema Controle Acesso Raspberry",
    "explanation": "Um sistema de controle de acesso para Raspberry Pi que gerencia portas, portões e catracas. Ele se integra com leitores RFID (Wiegand, Abatrack), um leitor biométrico e um aplicativo de QR Code. O sistema se comunica com um servidor central via API REST, suporta configuração remota, e possui um banco de dados SQLite local para operação offline e cache de crachás.",
    "children": [
        {
            "name": "Orquestração (main.py)",
            "explanation": "Ponto de entrada do sistema. Orquestra a inicialização de todos os componentes de hardware e software, iniciando cada módulo principal como uma thread separada, baseado no 'config.ini'.",
            "children": [
                {
                    "name": "Função inicializacao_pinos",
                    "explanation": "Configura todos os pinos GPIO necessários como entrada ou saída e define seus estados iniciais seguros, como travar solenoides e apagar LEDs."
                },
                {
                    "name": "Função modificaHostname",
                    "explanation": "Verifica se o hostname do dispositivo corresponde aos últimos 4 dígitos de seu número de série. Se não, atualiza o hostname e reinicia o sistema."
                },
                {
                    "name": "Função principal",
                    "explanation": "Inicia e gerencia as threads para os módulos de Display, Biometria, Leitor RFID, Banco de Dados, Controle de Roleta/Porta e Socket de QR Code."
                },
                {
                    "name": "Variáveis Globais (Global.py)",
                    "explanation": "Define variáveis globais para compartilhar estados entre as diferentes threads, como 'ENTRADA_LIBERADA', 'FINALIZOU_GIRO', 'ULTIMO_CARTAO' e 'EH_BIOMETRIA'."
                }
            ]
        },
        {
            "name": "Config (Config.py)",
            "explanation": "Classe que lê e fornece acesso aos parâmetros do arquivo 'config.ini', além de obter informações do sistema como S/N e gateway de rede.",
            "children": [
                {
                    "name": "Método __init__",
                    "explanation": "No construtor, lê 'config.ini', obtém S/N do Raspberry Pi e prefixo do gateway via comandos de shell, e carrega todos os parâmetros em atributos da classe."
                },
                {
                    "name": "Métodos de Verificação",
                    "explanation": "Fornece funções booleanas como 'is_porta()', 'is_catraca()', e 'has_biometria()' para que a lógica da aplicação se adapte ao tipo de equipamento configurado."
                },
                {
                    "name": "Método gravar_em_configini",
                    "explanation": "Permite que outros módulos atualizem programaticamente os valores no arquivo 'config.ini' usando a biblioteca configparser."
                }
            ]
        },
        {
            "name": "Banco (banco.py)",
            "explanation": "Classe que gerencia um banco de dados SQLite para cache de crachás autorizados e para armazenar registros de acesso durante a operação offline.",
            "children": [
                {
                    "name": "Método consulta_cracha_cache",
                    "explanation": "Verifica se um crachá (convertido para formatos W, S, A, P) existe na tabela local 'cracha' e se sua data de validade é vigente."
                },
                {
                    "name": "Threads de Sincronização",
                    "explanation": "Os métodos 'inicia_atualizacao' e 'inicia_envio_registros_offline' iniciam threads para tarefas de fundo.",
                    "children": [
                        {
                            "name": "Thread atualiza_crachas_autorizados",
                            "explanation": "Roda uma vez por dia, chama a API 'crachasAutorizados', apaga a tabela local 'cracha' e a repopula com os novos dados recebidos."
                        },
                        {
                            "name": "Thread envia_registros_offline",
                            "explanation": "Roda a cada hora, busca por registros com situação 'N', os envia para a API 'registrosOffline' e, em caso de sucesso, atualiza a situação para 'S'."
                        }
                    ]
                },
                {
                    "name": "Método insere_registro",
                    "explanation": "Salva um evento de acesso na tabela 'registro' com o status 'N' (Não enviado), para ser sincronizado posteriormente pela thread de envio."
                }
            ]
        },
        {
            "name": "RFID (RFID.py)",
            "explanation": "Classe base abstrata e suas implementações concretas (RFID_Rasp.py, RFID_Rasp_Abatrack.py) para leitura e processamento de cartões.",
            "children": [
                {
                    "name": "Lógica Comum (Classe Abstrata)",
                    "explanation": "Define a lógica principal de validação, incluindo anti-repetição, chamada à API REST, fallback para modo offline e atualização do display.",
                    "children": [
                        {
                            "name": "Método chama_ws_cracha",
                            "explanation": "Inicia a validação em uma nova thread, tratando da lógica anti-repetição do mesmo cartão e definindo variáveis globais."
                        },
                        {
                            "name": "Método processar_retorno_rest",
                            "explanation": "Interpreta a resposta da API, chamando 'ControlePinos' para liberar ou negar o acesso."
                        },
                        {
                            "name": "Método processa_offline",
                            "explanation": "Em caso de falha de rede, consulta o cache do Banco de dados e, se o cartão for válido, libera o acesso e registra a transação localmente."
                        }
                    ]
                },
                {
                    "name": "Implementação Wiegand",
                    "explanation": "A classe RFID_Rasp decodifica sinais Wiegand. Usa interrupções nos pinos D0 (bit '1') e D1 (bit '0') para construir a sequência de 26 bits."
                },
                {
                    "name": "Implementação Abatrack",
                    "explanation": "A classe RFID_Rasp_Abatrack decodifica Abatrack. Usa D0 como clock e lê o dado em D1. Inverte a string de bits resultante antes da conversão."
                }
            ]
        },
        {
            "name": "Biometria (biometria.py)",
            "explanation": "Classe que gerencia a captura e validação de impressões digitais através de um script externo e da API REST.",
            "children": [
                {
                    "name": "Método run (Loop Principal)",
                    "explanation": "Em uma thread, executa o script 'biometria.sh' em loop. Se o script for bem-sucedido, lê o arquivo de imagem gerado."
                },
                {
                    "name": "Método chamaWsBiometria",
                    "explanation": "Codifica a imagem em Base64 e a envia via POST para o endpoint 'controleAcessoBiometria' para validação, tratando de erros de comunicação e reiniciando a interface de rede se necessário."
                },
                {
                    "name": "Método processarRetornoRest",
                    "explanation": "Se a API retornar 'Ok', libera o acesso via 'ControlePinos', define variáveis globais e, para portas, gera um registro de movimento."
                }
            ]
        },
        {
            "name": "ControlePinos (ControlePinos.py)",
            "explanation": "Classe que abstrai o acionamento de hardware, como LEDs e travas, gerenciando a duração dos acionamentos via threads.",
            "children": [
                {
                    "name": "Métodos de Liberação",
                    "explanation": "Funções como 'libera_entrada' e 'libera_saida' que iniciam threads para controlar a liberação temporizada de travas e LEDs."
                },
                {
                    "name": "Métodos de Controle de Tempo",
                    "explanation": "As threads, como 'controla_tempo_entrada_liberada', ativam o hardware e aguardam em um loop até que o tempo expire ou um sensor de giro ('FINALIZOU_GIRO') seja ativado."
                },
                {
                    "name": "Métodos de Bloqueio/Negação",
                    "explanation": "Funções como 'nega_entrada' e 'bloqueia_roleta' que acionam o LED de acesso negado ou travam fisicamente o hardware."
                }
            ]
        },
        {
            "name": "Roleta (roleta.py)",
            "explanation": "Classe que implementa uma máquina de estados para monitorar sensores de rotação da catraca e garantir que a passagem seja autorizada.",
            "children": [
                {
                    "name": "Callback de Interrupção",
                    "explanation": "Função principal que implementa a máquina de estados. É acionada por qualquer mudança nos sensores de giro.",
                    "children": [
                        {
                            "name": "Lógica de Estados de Giro",
                            "explanation": "Transita por estados ('parado', 'comeco_giro', 'giro_1', 'giro_2') para rastrear o progresso e a direção de um giro."
                        },
                        {
                            "name": "Mecanismo de Bloqueio",
                            "explanation": "Se uma tentativa de giro ocorre sem autorização ('ENTRADA_LIBERADA' é False), aciona a trava da roleta e entra em estado 'bloqueado'."
                        },
                        {
                            "name": "Registro de Movimento Pós-Giro",
                            "explanation": "Após um giro completo, chama a API 'geraMovimento' para registrar o evento, com lógica de nova tentativa e fallback para registro offline."
                        }
                    ]
                }
            ]
        },
        {
            "name": "Display (display.py)",
            "explanation": "Classe que controla um display LCD 16x2 para exibir o status do sistema e mensagens ao usuário.",
            "children": [
                {
                    "name": "Método clock",
                    "explanation": "Verifica continuamente o status da rede (cabo, ping, API) e atualiza o display com o estado correspondente: 'OFFLINE', 'CONECTANDO', 'ERRO COMUN. REST', etc."
                },
                {
                    "name": "Método mostrar_msg_gateway_predio_ip",
                    "explanation": "Ao conectar na rede, obtém dados da rede, atualiza o 'config.ini' com dados específicos do prédio e exibe essas informações no display."
                },
                {
                    "name": "Método addAguarda",
                    "explanation": "Exibe uma mensagem 'Aguarde...' animada durante o processamento de uma validação."
                }
            ]
        },
        {
            "name": "Socket_Qrcode (SocketQrCode.py)",
            "explanation": "Classe que abre uma porta TCP (5000) para receber comandos de acesso via QR Code de um aplicativo externo.",
            "children": [
                {
                    "name": "Método run (Loop Principal)",
                    "explanation": "Inicia um servidor de socket na porta 5000, aguarda conexões e lê os dados recebidos."
                },
                {
                    "name": "Processamento de JSON",
                    "explanation": "Interpreta a mensagem recebida como um objeto JSON. Se o status for 'Ok', libera o acesso usando 'ControlePinos' com base no 'sentidoLiberado'. Caso contrário, nega."
                }
            ]
        },
        {
            "name": "Configuração por Rede e Remota",
            "explanation": "Classes e scripts que permitem a configuração do dispositivo baseada na rede e por comandos remotos do backend. Envolve múltiplos arquivos.",
            "children": [
                {
                    "name": "ConfigUnicaPorPredio.py",
                    "explanation": "Classe que verifica o gateway da rede e, usando um dicionário (DicionarioGateway...), aplica configurações de API específicas do prédio, reiniciando o serviço se necessário."
                },
                {
                    "name": "ConfiguradorCatracaNoSCA.py",
                    "explanation": "Classe que envia periodicamente os dados de configuração do coletor (IP, S/N, timeouts) para a API do Sistema de Controle de Acesso (SCA)."
                },
                {
                    "name": "GerenciadorConfiguracoes...",
                    "explanation": "Script que aceita parâmetros de configuração via linha de comando, permitindo que o backend altere as configurações do dispositivo. Valida o S/N antes de aplicar as mudanças."
                }
            ]
        },
        {
            "name": "Porta (Porta.py)",
            "explanation": "Classe que controla a lógica para portas e portões, acionando a trava por um tempo determinado quando um sensor de abertura é ativado.",
            "children": [
                {
                    "name": "Callback de Interrupção",
                    "explanation": "Quando o sensor da porta é ativado, inicia uma thread para executar 'controla_tempo_porta_aberta'."
                },
                {
                    "name": "Método controla_tempo_porta_aberta",
                    "explanation": "Aciona o relé do ímã da porta (destrava), aguarda pelo tempo definido em 'config.ini' e, em seguida, desativa o relé (trava)."
                }
            ]
        }
    ]
}