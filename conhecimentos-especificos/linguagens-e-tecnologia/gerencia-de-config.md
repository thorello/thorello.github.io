### Ol√°, futuro(a) aprovado(a)\! Vamos controlar as vers√µes do seu estudo e configurar sua mente para gabaritar o Cebraspe.

Pense em Ger√™ncia de Configura√ß√£o e Git como o processo de **escrever um livro em equipe** ‚úçÔ∏è. Voc√™ precisa de um sistema para que v√°rios autores possam trabalhar juntos sem que um apague o trabalho do outro e para manter um hist√≥rico de todas as vers√µes do manuscrito.

-----

### \#\#\# Ger√™ncia de Configura√ß√£o e Git: A M√°gica de Escrever em Equipe

  * **O que √© um VCS (Sistema de Controle de Vers√£o)?** √â o sistema que a equipe de autores usa.

      * **Centralizado (O Jeito Antigo):** H√° apenas **um manuscrito mestre** guardado na editora. Para escrever, o autor precisa pegar o manuscrito, levar para casa, e depois devolver. Se a editora pegar fogo, todo o trabalho √© perdido.
      * **Distribu√≠do (O Jeito Git):** Cada autor tem uma **c√≥pia completa e m√°gica do livro inteiro**, com todo o seu hist√≥rico, em seu pr√≥prio notebook. Ele pode escrever cap√≠tulos inteiros (`commit`) offline no avi√£o. A editora √© apenas um lugar para sincronizar as c√≥pias.

  * **As 3 √Åreas de Trabalho do Git:** √â o fluxo de trabalho de um autor.

    1.  **Diret√≥rio de Trabalho (A Sua Mesa):** Onde voc√™ est√° escrevendo e rabiscando o cap√≠tulo. O texto est√° **Modificado**.
    2.  **√Årea de Prepara√ß√£o (*Staging Area*):** A sua **"pasta de revis√£o"**. Voc√™ gostou de um par√°grafo. Voc√™ o move para essa pasta para inclu√≠-lo na pr√≥xima vers√£o oficial. O texto est√° **Preparado (*Staged*)**. O comando para isso √© `git add`.
    3.  **Reposit√≥rio (Seu Hist√≥rico Local):** No final do dia, voc√™ pega tudo o que est√° na "pasta de revis√£o" e salva permanentemente como uma nova vers√£o no seu caderno de hist√≥rico. O texto est√° **Consolidado (*Committed*)**. O comando para isso √© `git commit`.

> #### Foco Cebraspe (Pontos de Aten√ß√£o e "Pegadinhas")
>
> >   * **Distribu√≠do vs. Centralizado:** A banca vai dizer que o Git precisa de conex√£o com o servidor para fazer `commit`. **ERRADO\!** O `commit` √© uma opera√ß√£o **local**. Voc√™ s√≥ precisa de conex√£o para sincronizar (`push`/`pull`).
> >   * **A *Staging Area* √© a Chave:** A banca vai dizer que `git add` salva a mudan√ßa no reposit√≥rio. **ERRADO\!** `git add` move da sua mesa para a **pasta de revis√£o (*Staging Area*)**. √â o `git commit` que salva o que est√° na pasta de revis√£o para o seu hist√≥rico.

-----

### \#\#\# Branches e Gitflow: Escrevendo Universos Paralelos

  * **Branch (Ramifica√ß√£o):** √â como criar um **universo paralelo** para o livro. Enquanto um autor escreve a hist√≥ria principal, outro pode criar um `branch` para escrever um cap√≠tulo experimental com um novo personagem, sem bagun√ßar a trama principal.

  * **Gitflow (O M√©todo de Escrita da Editora):** √â uma estrat√©gia famosa para organizar os `branches`.

      * **`master` (ou `main`):** A prateleira da livraria com os **livros j√° publicados**. √â o c√≥digo em produ√ß√£o.
      * **`develop`:** A **mesa de edi√ß√£o principal**, onde os cap√≠tulos finalizados s√£o juntados para a pr√≥xima edi√ß√£o do livro.
      * **`feature/*` (Cap√≠tulo Novo):** Rascunho para uma nova funcionalidade. **Sai de `develop` e volta para `develop`**.
      * **`release/*` (Revis√£o Final):** O livro indo para a gr√°fica. **Sai de `develop` e volta para `master` E `develop`**.
      * **`hotfix/*` (Corre√ß√£o Urgente):** Corrigir um erro grave no livro j√° publicado. **Sai de `master` e volta para `master` E `develop`**.

> #### Foco Cebraspe (Pontos de Aten√ß√£o e "Pegadinhas")
>
> >   * O fluxo dos branches no Gitflow √© o alvo principal. A banca vai dizer que uma `feature` sai da `master`. **ERRADO\!** Sai da `develop`.
> >   * V√£o dizer que um `hotfix` volta s√≥ para a `master`. **ERRADO\!** Ele precisa voltar para a `develop` tamb√©m, para que a corre√ß√£o n√£o se perca na pr√≥xima edi√ß√£o.

-----

### \#\#\# Merge e Colabora√ß√£o: Juntando as Hist√≥rias

  * **`git merge`:** √â o ato do editor-chefe de **juntar** o cap√≠tulo experimental de um autor (`branch`) com o manuscrito principal.
  * **Conflito de Merge:** Acontece quando dois autores, em seus universos paralelos, reescreveram o **mesmo par√°grafo** de formas diferentes. O sistema n√£o consegue decidir qual √© o certo e pede uma interven√ß√£o manual do editor.
  * **`git rebase`:** Uma alternativa ao `merge` que **reescreve a hist√≥ria**, criando uma linha do tempo mais limpa, como se um autor tivesse escrito seu cap√≠tulo depois do outro, sequencialmente. √â uma ferramenta poderosa, mas perigosa se usada em cap√≠tulos que j√° foram compartilhados.

> #### Foco Cebraspe (Pontos de Aten√ß√£o e "Pegadinhas")
>
> >   * **`merge` vs. `rebase`:** **`merge`** preserva o hist√≥rico real (com "n√≥s" e ramifica√ß√µes) e √© seguro. **`rebase`** cria um hist√≥rico linear e bonito, mas **altera o passado**, o que pode ser problem√°tico em ramos p√∫blicos.
> >   * **`git pull`** √© um atalho para `git fetch` (baixar as novidades) + `git merge` (juntar com o seu trabalho).

-----

### \#\#\# CI/CD e GitLab: A Gr√°fica Automatizada

  * **Integra√ß√£o Cont√≠nua (CI):** Toda vez que um autor envia um novo par√°grafo, um **rob√¥ revisor** automaticamente verifica a gram√°tica e se o texto se encaixa com o resto do livro.

  * **Entrega Cont√≠nua (*Continuous Delivery*):** Se o rob√¥ revisor aprova o texto, ele automaticamente gera um **e-book** e o deixa pronto, apenas esperando o "OK" do editor-chefe para publicar.

  * **Implanta√ß√£o Cont√≠nua (*Continuous Deployment*):** O mesmo que o anterior, mas o "OK" √© autom√°tico. O e-book √© publicado na Amazon no mesmo instante em que o rob√¥ o aprova.

  * **GitLab:** √â a **editora moderna e completa**. Ela oferece o dep√≥sito de manuscritos (Git), o controle de tarefas e a gr√°fica automatizada (**GitLab CI/CD**) em um s√≥ lugar. A "receita" da automa√ß√£o da gr√°fica √© escrita em um arquivo chamado **`.gitlab-ci.yml`**.

> #### Foco Cebraspe (Pontos de Aten√ß√£o e "Pegadinhas")
>
> >   * A diferen√ßa entre os dois "CDs": Na **Entrega** (*Delivery*), a publica√ß√£o final √© **manual**. Na **Implanta√ß√£o** (*Deployment*), a publica√ß√£o final √© **autom√°tica**.
> >   * O cora√ß√£o da automa√ß√£o no GitLab √© o arquivo **`.gitlab-ci.yml`**, que define a *pipeline* como c√≥digo.

### \#\#\# Mapa Mental: O Fluxo de Trabalho do Gitflow

```mermaid
%%{init: {"theme": "tokyo-midnight", "themeVariables": { "fontFamily": "lexend"}}}%%
graph TD
    subgraph "Produ√ß√£o (Livros Publicados)"
        M["üìò master/main"]
    end
    
    subgraph "Desenvolvimento (Pr√≥xima Edi√ß√£o)"
        D["üìô develop"]
    end

    subgraph "Rascunhos (Trabalho em Andamento)"
        F["‚≠ê feature/nova-ideia"]
        R["üîñ release/v1.2"]
        H["üî• hotfix/bug-critico"]
    end
    
    D -- "Cria um rascunho<br>para uma nova funcionalidade" --> F
    F -- "Finaliza e integra<br>na pr√≥xima edi√ß√£o" --> D

    D -- "Prepara para<br>lan√ßamento" --> R
    R -- "Lan√ßa na livraria" --> M
    R -- "Incorpora ajustes<br>de volta" --> D

    M -- "Encontra um erro<br>grave no livro" --> H
    H -- "Lan√ßa a corre√ß√£o<br>na livraria" --> M
    H -- "Incorpora a corre√ß√£o<br>na pr√≥xima edi√ß√£o" --> D
```


### **Classe:** B
### **Conte√∫do:** Ger√™ncia de Configura√ß√£o e Versionamento com Git

---

### **1. Ger√™ncia de Configura√ß√£o e Versionamento com Git**

> #### **TEORIA-ALVO**
> A Ger√™ncia de Configura√ß√£o de Software (GCS) √© a disciplina de engenharia de software que visa controlar a evolu√ß√£o de um sistema de software, gerenciando seus artefatos, as vers√µes e as mudan√ßas realizadas sobre eles. A ferramenta central da GCS moderna √© o Sistema de Controle de Vers√£o (VCS).
>
> * **Tipos de VCS:**
>     * **Centralizado (CVCS):** Existe um √∫nico servidor central que cont√©m todo o c√≥digo versionado. Clientes fazem *checkout* de uma c√≥pia de trabalho. Ex: Subversion (SVN), CVS.
>     * **Distribu√≠do (DVCS):** Cada cliente possui um clone completo do reposit√≥rio, incluindo todo o seu hist√≥rico. Permite opera√ß√µes offline, como *commits* e visualiza√ß√£o de hist√≥rico. Ex: **Git**, Mercurial.
> * **Git - Conceitos Fundamentais:**
>     * **Natureza Distribu√≠da:** A principal caracter√≠stica. Cada desenvolvedor tem uma c√≥pia local e completa do reposit√≥rio.
>     * **Reposit√≥rio (`.git`):** O diret√≥rio onde o Git armazena os metadados e o banco de dados de objetos do projeto.
>     * **Tr√™s Estados/√Åreas:** Um arquivo no Git pode estar em tr√™s estados principais, correspondentes a tr√™s √°reas:
>         1.  **Modified (Modificado):** O arquivo foi alterado no **Diret√≥rio de Trabalho (*Working Directory*)**, mas ainda n√£o foi preparado para o *commit*.
>         2.  **Staged (Preparado/Em Espera):** O arquivo modificado foi marcado para ser inclu√≠do no pr√≥ximo *commit*. Esta √°rea √© conhecida como **√Årea de Prepara√ß√£o (*Staging Area*)** ou **Index**. O comando `git add` move as mudan√ßas para esta √°rea.
>         3.  **Committed (Consolidado):** Os dados est√£o armazenados de forma segura no reposit√≥rio local. O comando `git commit` move as mudan√ßas da *Staging Area* para o reposit√≥rio.

> #### **FOCO CEBRASPE (Pontos de Aten√ß√£o e "Pegadinhas")**
> > * **Distribu√≠do vs. Centralizado:** A banca frequentemente explora esta diferen√ßa. Uma afirma√ß√£o de que "o Git requer conex√£o constante com um servidor central para que um desenvolvedor possa realizar *commits*" est√° **ERRADA**. *Commits* s√£o opera√ß√µes locais em um DVCS. A conex√£o √© necess√°ria apenas para sincronizar com reposit√≥rios remotos (`git push`, `git pull`).
> > * **A Fun√ß√£o da Staging Area (Index):** Este √© um diferencial do Git e um ponto cr√≠tico em provas. A banca pode afirmar que o comando `git add` envia as modifica√ß√µes diretamente para o reposit√≥rio. **ERRADO**. O comando `git add` move as altera√ß√µes do Diret√≥rio de Trabalho para a **Staging Area**. √â o comando `git commit` que efetivamente grava as mudan√ßas preparadas na *Staging Area* para o reposit√≥rio local.
> > * **Snapshot, n√£o Diferen√ßas:** O Git armazena seu hist√≥rico como uma s√©rie de *snapshots* (instant√¢neos) do estado do projeto, e n√£o como uma lista de diferen√ßas entre arquivos (deltas), como em alguns outros sistemas.

---

### **Classe:** B
### **Conte√∫do:** Branch e Estrat√©gias de Ramifica√ß√£o (Gitflow)

---

### **2. Branches e Estrat√©gias de Ramifica√ß√£o (Gitflow)**

> #### **TEORIA-ALVO**
> Um *branch* (ramifica√ß√£o) no Git √© um ponteiro leve e m√≥vel para um *commit*. √â um mecanismo que permite o desenvolvimento de funcionalidades, corre√ß√µes ou experimentos de forma isolada, sem afetar a linha principal de desenvolvimento. O Git incentiva o uso extensivo de *branches*.
>
> * **HEAD:** √â um ponteiro especial que indica em qual *branch* o desenvolvedor est√° trabalhando no momento.
> * **Gitflow:** √â um modelo de fluxo de trabalho (workflow) e uma estrat√©gia de ramifica√ß√£o prescritiva para o Git. Ele define nomes e pap√©is espec√≠ficos para diferentes tipos de *branches* para organizar o desenvolvimento.
>     * **Branches Principais (Longa Dura√ß√£o):**
>         * **`master` (ou `main`):** Reflete o c√≥digo em produ√ß√£o. Todo *commit* na `master` √© uma nova vers√£o de produ√ß√£o e deve receber uma *tag*.
>         * **`develop`:** √â a linha de desenvolvimento principal, onde as funcionalidades s√£o integradas para a pr√≥xima *release*. Representa o estado mais recente do desenvolvimento.
>     * **Branches de Suporte (Curta Dura√ß√£o):**
>         * **`feature/*`:** Usadas para desenvolver novas funcionalidades. **Partem de `develop` e s√£o mescladas de volta em `develop`**.
>         * **`release/*`:** Usadas para preparar uma nova vers√£o de produ√ß√£o (realizar testes finais, corrigir pequenos bugs). **Partem de `develop` e s√£o mescladas de volta em `develop` E `master`**.
>         * **`hotfix/*`:** Usadas para corrigir bugs cr√≠ticos em produ√ß√£o de forma r√°pida. **Partem de `master` e s√£o mescladas de volta em `develop` E `master`**.

> #### **FOCO CEBRASPE (Pontos de Aten√ß√£o e "Pegadinhas")**
> > * **Fluxo dos Branches no Gitflow:** A origem e o destino dos *branches* de suporte s√£o o ponto mais cobrado. A banca vai afirmar que "uma *feature branch* no Gitflow parte da `master`". **ERRADO**. Parte de `develop`. A banca afirmar√° que "uma *hotfix branch* √© mesclada apenas na `master`". **ERRADO**. Deve ser mesclada tamb√©m na `develop` para que a corre√ß√£o seja incorporada na pr√≥xima *release* e n√£o seja perdida.
> > * **Prop√≥sito da `master` e `develop`:** A banca pode confundir os pap√©is. O desenvolvimento cotidiano e a integra√ß√£o de novas funcionalidades ocorrem na `develop`. A `master` deve permanecer est√°vel, refletindo apenas as vers√µes lan√ßadas em produ√ß√£o.
> > * **Gitflow como √önica Estrat√©gia:** Gitflow √© um workflow, mas n√£o o √∫nico (existem outros, como GitHub Flow ou GitLab Flow). A banca pode trat√°-lo como uma regra inerente ao Git. **INCORRETO**. √â um modelo de trabalho, n√£o um comando ou funcionalidade do Git.

---

### **Classe:** B
### **Conte√∫do:** Merge e Colabora√ß√£o

---

### **3. Merge e Colabora√ß√£o**

> #### **TEORIA-ALVO**
> A colabora√ß√£o em Git √© fundamentada na capacidade de integrar o trabalho realizado em diferentes *branches*. O principal comando para essa integra√ß√£o √© o `git merge`.
>
> * **`git merge`:** Comando utilizado para unificar o hist√≥rico de dois ou mais *branches*.
>     * **Merge *fast-forward*:** Ocorre quando o *branch* de destino est√° em um ancestral direto do *branch* que est√° sendo mesclado. O Git simplesmente move o ponteiro do *branch* de destino para frente, sem criar um novo *commit*.
>     * **Merge de 3-vias (*three-way merge*):** Ocorre quando os hist√≥ricos dos *branches* divergem. O Git localiza um ancestral comum e cria um novo *commit* de *merge*, que possui dois *commits* pais.
> * **Conflito de Merge:** Situa√ß√£o que ocorre quando o Git n√£o consegue unificar as mudan√ßas automaticamente, pois a mesma por√ß√£o de um arquivo foi alterada em ambos os hist√≥ricos que est√£o sendo mesclados. O Git pausa o processo e exige que o desenvolvedor resolva o conflito manualmente.
> * **`git rebase`:** √â uma alternativa ao `merge` para integrar mudan√ßas. Em vez de criar um *commit* de *merge*, o `rebase` reescreve o hist√≥rico do *branch* atual, aplicando seus *commits* sobre o topo do *branch* de destino, resultando em um hist√≥rico linear.
> * **Comandos Colaborativos:** `git clone` (cria uma c√≥pia local de um reposit√≥rio remoto), `git pull` (busca e mescla mudan√ßas de um reposit√≥rio remoto), `git push` (envia *commits* locais para um reposit√≥rio remoto).

> #### **FOCO CEBRASPE (Pontos de Aten√ß√£o e "Pegadinhas")**
> > * **`merge` vs. `rebase`:** A distin√ß√£o √© um ponto t√©cnico avan√ßado e test√°vel. **`merge`** preserva o hist√≥rico como ele ocorreu, criando um grafo n√£o linear, e √© seguro para *branches* p√∫blicos. **`rebase`** cria um hist√≥rico limpo e linear, mas **reescreve o hist√≥rico de *commits***, sendo perigoso para *branches* que j√° foram compartilhados com outros desenvolvedores. Afirmar que `rebase` deve ser usado para atualizar um *branch* p√∫blico como a `master` √© **ERRADO** e uma m√° pr√°tica.
> > * **Conflito de Merge n√£o √© um Erro:** Um conflito n√£o √© um erro do Git, mas uma consequ√™ncia natural do trabalho paralelo. √â uma pausa no processo que exige interven√ß√£o humana para tomar a decis√£o correta.
> > * **`git pull`:** Este comando √©, na verdade, um atalho para dois outros comandos: `git fetch` (que baixa os dados do reposit√≥rio remoto) seguido de `git merge` (que mescla o *branch* remoto correspondente no *branch* local atual).

---

### **Classe:** C
### **Conte√∫do:** CI/CD, Pipelines e GitLab

---

### **4. CI/CD, Pipelines e GitLab**

> #### **TEORIA-ALVO**
> CI/CD √© um conjunto de pr√°ticas que visa automatizar as etapas do ciclo de vida de desenvolvimento de software, permitindo entregas mais r√°pidas e confi√°veis.
>
> * **Integra√ß√£o Cont√≠nua (CI - *Continuous Integration*):** √â a pr√°tica de automatizar a integra√ß√£o de mudan√ßas de c√≥digo de m√∫ltiplos desenvolvedores em um √∫nico reposit√≥rio de software. Cada integra√ß√£o √© verificada por um *build* automatizado e pela execu√ß√£o de testes automatizados.
> * **Entrega Cont√≠nua (CD - *Continuous Delivery*):** √â a extens√£o da CI, onde as mudan√ßas que passam por todas as etapas de teste s√£o automaticamente empacotadas e preparadas para o lan√ßamento. A implanta√ß√£o no ambiente de produ√ß√£o final ainda √© um passo manual e deliberado.
> * **Implanta√ß√£o Cont√≠nua (CD - *Continuous Deployment*):** √â a etapa seguinte √† Entrega Cont√≠nua. Cada mudan√ßa que passa com sucesso por todo o *pipeline* √© automaticamente implantada em produ√ß√£o.
> * **Pipeline:** Representa o fluxo de automa√ß√£o do processo de CI/CD. √â composto por uma sequ√™ncia de est√°gios (*stages*) e trabalhos (*jobs*), como `build` (compila√ß√£o), `test` (teste), e `deploy` (implanta√ß√£o).
> * **GitLab e GitLab CI/CD:**
>     * **GitLab:** Uma plataforma DevOps completa que fornece, em uma √∫nica aplica√ß√£o, gerenciamento de reposit√≥rios Git, rastreamento de issues, e um sistema de CI/CD integrado.
>     * **GitLab CI/CD:** A funcionalidade de CI/CD do GitLab. As *pipelines* s√£o definidas em um arquivo de texto formatado em YAML, chamado **`.gitlab-ci.yml`**, localizado na raiz do reposit√≥rio. Este arquivo descreve os est√°gios e os *jobs* a serem executados por agentes chamados **GitLab Runners**.

> #### **FOCO CEBRASPE (Pontos de Aten√ß√£o e "Pegadinhas")**
> > * **Diferen√ßa entre os CDs (*Delivery* vs. *Deployment*):** Esta √© a principal fonte de confus√£o. A **Entrega Cont√≠nua** (*Delivery*) termina com o artefato pronto para ser implantado, mas o *deploy* em produ√ß√£o √© **manual**. A **Implanta√ß√£o Cont√≠nua** (*Deployment*) automatiza tamb√©m o *deploy* em produ√ß√£o.
> > * **`.gitlab-ci.yml`:** Este arquivo √© o cora√ß√£o da automa√ß√£o no GitLab. A banca pode afirmar que as *pipelines* s√£o configuradas exclusivamente atrav√©s da interface gr√°fica. **ERRADO**. A defini√ß√£o da *pipeline* como c√≥digo no arquivo `.gitlab-ci.yml` √© a pr√°tica padr√£o e permite o versionamento da pr√≥pria *pipeline* junto com o c√≥digo da aplica√ß√£o (*Pipeline as Code*).
> > * **Pipeline como Processo Manual:** A ess√™ncia de uma *pipeline* de CI/CD √© a **automa√ß√£o**. Descrever a *pipeline* como uma sequ√™ncia de tarefas manuais √© conceitualmente **ERRADO**.
> > * **GitLab Runner:** √â o agente que executa os *jobs* definidos no `.gitlab-ci.yml`. Sem *runners* configurados e dispon√≠veis, a *pipeline* n√£o pode ser executada.
